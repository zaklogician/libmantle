--
-- Copyright 2023, COMAS (ABN 11 932 720 318) and the project contributors
-- SPDX-License-Identifier: BSD-3-Clause
--

import Mantle.Common (
  Notifiable, notify,
  Callable, ppcall,
  Ackable, acknowledge, postpone,
  Surrenderable, surrender,
  Readable, toSpan,
  Writable, toSpanWrite,
  MessageInfo,
  Message,
  MantleUserCap
);

import Mantle.Generated (
  Ch01Cap, mintCh01,
  Ch02Cap, mintCh02,
  Ch00Irq,
  MemoryCaps, PinpadInputRCap,
  NotificationSource,
  PpcallSource
);

module body Program is

    -- slots in local state
    constant CURRENT_CLIENT: Index := 0;
    constant ENTERED_DIGITS: Index := 1;
    constant CORRECT: Index := 2;

    union PinBuffer: Free is
        case Await0;
        case Await1 is
            digit0: Nat8;
        case Await2 is
            digit0: Nat8;
            digit1: Nat8;
        case Await3 is
            digit0: Nat8;
            digit1: Nat8;
            digit2: Nat8;
        case Full is
            digit0: Nat8;
            digit1: Nat8;
            digit2: Nat8;
            digit3: Nat8;
    end;

    function appendDigit(pinBuffer: PinBuffer, digit: Nat8): PinBuffer is
        case pinBuffer of
            when Await0() do
                return Await1(digit0 => digit);
            when Await1(digit0: Nat8) do
                return Await2(digit0 => digit0, digit1 => digit);
            when Await2(digit0: Nat8, digit1: Nat8) do
                return Await3(digit0 => digit0, digit1 => digit1, digit2 => digit);
            when Await3(digit0: Nat8, digit1: Nat8, digit2: Nat8) do
                return Full(digit0 => digit0, digit1 => digit1, digit2 => digit2, digit3 => digit);
            when Full(digit0: Nat8, digit1: Nat8, digit2: Nat8, digit3: Nat8) do
                return Full(digit0 => digit0, digit1 => digit1, digit2 => digit2, digit3 => digit3);
        end case;
    end;

    function correctPin(digit0: Nat8, digit1: Nat8, digit2: Nat8, digit3: Nat8): Bool is
        if (not (digit0 = 5)) then
            return false;
        end if;
        if (not (digit1 = 4)) then
            return false;
        end if;
        if (not (digit2 = 3)) then
            return false;
        end if;
        if (not (digit3 = 2)) then
            return false;
        end if;
        return true;
    end;

    union Client: Free is
        case Client1;
        case Client2;
    end;

    union LocalState: Free is
        case NoClient;
        case HaveClient is
            client: Client;
            pinBuffer: PinBuffer;
    end;

    generic [R: Region]
    function notifyClient(cap: &[MantleUserCap,R], client: Client): Unit is
        case client of
            when Client1() do
                let ch01: Ch01Cap := mintCh01(cap);
                notify(&ch01);
                surrender(ch01);
            when Client2() do
                let ch02: Ch02Cap := mintCh02(cap);
                notify(&ch02);
                surrender(ch02);
        end case;
        return nil;
    end;

    function notified(cap: MantleUserCap, mem: MemoryCaps, source: NotificationSource, state: LocalState): LocalState is
        case source of
            when Ch00(irq: Ch00Irq) do
                -- handle IRQ here
                printLn("IRQ on ch 0.");
                let { pinpadInput : PinpadInputRCap } := mem;
                case state of
                    when NoClient() do
                        -- we can ignore the input
                        acknowledge(irq);
                        surrender(pinpadInput);
                        surrender(cap);
                        return NoClient();
                    when HaveClient(client: Client, pinBuffer: PinBuffer) do
                        var digit: Nat8 := 0;
                        borrow pi: &[PinpadInputRCap, R] := &pinpadInput do
                            let input: Span[Nat8, R] := toSpan(pi);
                            digit := input[0];
                            printLn(input[0]);
                        end borrow;
                        surrender(pinpadInput);
                        acknowledge(irq);
                        let newPinBuffer: PinBuffer := appendDigit(pinBuffer, digit);
                        case newPinBuffer of
                            when Await0() do
                                surrender(cap);
                                return HaveClient(client => client, pinBuffer => newPinBuffer);
                            when Await1(digit0: Nat8) do
                                surrender(cap);
                                return HaveClient(client => client, pinBuffer => newPinBuffer);
                            when Await2(digit0: Nat8, digit1: Nat8) do
                                surrender(cap);
                                return HaveClient(client => client, pinBuffer => newPinBuffer);
                            when Await3(digit0: Nat8, digit1: Nat8, digit2: Nat8) do
                                surrender(cap);
                                return HaveClient(client => client, pinBuffer => newPinBuffer);
                            when Full(digit0: Nat8, digit1: Nat8, digit2: Nat8, digit3: Nat8) do
                                if correctPin(digit0, digit1, digit2, digit3) then
                                    notifyClient(&cap, client);
                                end if;
                                surrender(cap);
                                return NoClient(); 
                            end case;
                end case;
            when Ch01() do
                printLn("Notified on ch 1.");
                surrender(mem);
                surrender(cap);
                return state;
            when Ch02() do
                printLn("Notified on ch 2.");
                surrender(mem);
                surrender(cap);
                return state;
            when UnknownNotification(number: Nat32) do
                -- we hang if we receive an unknown notification
                while true do
                   skip;
                end while;
                surrender(mem);
                surrender(cap);
                return state;
        end case;
    end;

    function protected(cap: MantleUserCap, mem: MemoryCaps, source: PpcallSource, message: Message[LocalState]): Message[LocalState] is
        surrender(cap);
        surrender(mem);
        case source of
           when FromCh01() do
                printLn("Ppcall on ch 1.");
                case message.state of
                    when NoClient() do
                        let newState: LocalState :=
                            HaveClient(client => Client1(), pinBuffer => Await0());
                        let response: Message[LocalState] :=
                            Message(label => 1, count => 0, state => newState);
                        return response;
                    when HaveClient(client: Client, pinBuffer: PinBuffer) do
                        let response: Message[LocalState] :=
                            Message(label => 0, count => 0, state => message.state);
                        return response;
                end case;
           when FromCh02() do
                printLn("Ppcall on ch 2.");
                case message.state of
                    when NoClient() do
                        let newState: LocalState :=
                            HaveClient(client => Client2(), pinBuffer => Await0());
                        let response: Message[LocalState] :=
                            Message(label => 1, count => 0, state => newState);
                        return response;
                    when HaveClient(client: Client, pinBuffer: PinBuffer) do
                        printLn("Oops.");
                        let response: Message[LocalState] :=
                            Message(label => 0, count => 0, state => message.state);
                        return response;
                end case;
           when UnknownPpcall(number: Nat64) do
                -- we hang if we receive an unknown notification
                while true do
                   skip;
                end while;
                return message;
        end case;
    end;

    function init(cap: MantleUserCap, mem: MemoryCaps): LocalState is
        surrender(mem);
        surrender(cap);
        printLn("Hello World!");
        return NoClient();
    end;

end module body.

