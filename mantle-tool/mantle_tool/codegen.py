#
# Copyright 2023, COMAS (ABN 11 932 720 318) and the project contributors
# SPDX-License-Identifier: BSD-3-Clause
#

"""codegen.py

This module concerns code generation. It provides several classes and functions that are
used to generate APIs in the Austral programming language based on seL4 Core Platform
system descriptions. It's primary use is to convert an SDF system description file into
a set of Austral interfaces, data types and functions that can be used by a software
developer.

Key Classes and Functions:

- `Emitter`:
    This class is used to build the generated code by maintaining the 3 files
    (C headers, Austral module interface, Austral module implementation).

- `InletCap`, `InletCodeBuilder`, `MemoryCap`, `MemoryCodeBuilder`:
    These classes represent components of the Austral code to be generated.
    They contain methods for generating different parts of the code based on
    the inlets or memory regions they represent.

- `generate_api(the_registry: Registry, the_protection_domain: ProtectionDomain) -> Emitter`:
   This function is the entry point to the code generation process.
   It takes a registry and a protection domain as input, and returns an
   Emitter containing the generated Austral code.

Use of this module generally involves creating a registry object from a user-provided
SDF system description file, and then calling `generate_api` with this registry and
the desired protection domain. The entry point for hacking on the code generation itself
is the `make_all` method of the Cap and CodeBuilder classes.
"""

from types import MappingProxyType
from typing import Optional
from enum import Enum
from dataclasses import dataclass

from mantle_tool.registry import (ProtectionDomain, Inlet, CommChannel, IRQChannel, MappedMemoryRegion, Registry)


class Emitter:
    """
    Manages the emission of lines of code into Mantle's output files: the 'c', 'aui' and 'aum'.
    
    The 'aui' and 'aum' files represents the Austral module and interface respectively, while
    the 'c' represents code emitted to the C headers generated by Mantle.

    The caller has to make sure that the content across these files is kept synchronized;
    for example, a function declared in the 'aum' that is intended to be publicly accessible
    should have a prototype in the 'aui'.
    
    Every file type has an associated list of emitted lines and an indentation level.
    The class provides methods to append a line to the specific file's list with the current
    indentation for that file.
    
    Attributes
    ----------
    emitted_c : list[str]
        The list of emitted lines for the 'c' file.
    emitted_aui : list[str]
        The list of emitted lines for the 'aui' file.
    emitted_aum : list[str]
        The list of emitted lines for the 'aum' file.
    indentation_c : str
        The current indentation level for the 'c' file.
    indentation_aui : str
        The current indentation level for the 'aui' file.
    indentation_aum : str
        The current indentation level for the 'aum' file.

    Methods
    -------
    c(s: str) -> None
        Append a line to the list of lines the 'c' file, prefixed with the
        current 'c' indentation level.
    aui(s: str) -> None
        Append a line to the list of lines the 'aui' file, prefixed with the current
        'aui' indentation level.
    aum(s: str) -> None
        Append a line to the list of lines the 'aum' file, prefixed with the current
        'aum' indentation level.
    """
    def __init__(self) -> None:
        self.emitted_c: list[str] = list()
        self.emitted_aui: list[str] = list()
        self.emitted_aum: list[str] = list()

        self.indentation_c: str = ""
        self.indentation_aui: str = ""
        self.indentation_aum: str = ""

    def c(self, s: str) -> None:
        """
        Append a line to the list of lines the 'c' file, prefixed with the
        current 'c' indentation level.

        Parameters
        ----------
        s: str
            The string to append as a new line to the list.
        """
        self.emitted_c.append(self.indentation_c + s)

    def aui(self, s: str) -> None:
        """
        Append a line to the list of lines the 'aui' file, prefixed with the
        current 'aui' indentation level.

        Parameters
        ----------
        s: str
            The string to append as a new line to the list.
        """
        self.emitted_aui.append(self.indentation_aui + s)

    def aum(self, s: str) -> None:
        """
        Append a line to the list of lines the 'aum' file, prefixed with the
        current 'aum' indentation level.

        Parameters
        ----------
        s: str
            The string to append as a new line to the list.
        """
        self.emitted_aum.append(self.indentation_aum + s)


class InletSort(Enum):
    """
    The `InletSort` enumeration represents the 3 different categories of inlets
    one needs to distinguish for code generation purposes.

    `InletSort` includes the following:
    - `COMM_WITHOUT_PPCALL`: Represents inlets through which notifications can
      be sent across a channel, but protected procedure calls cannot be made,
      either because the other end provides no such calls, or because the
      other end has lower priority that the current end.
    - `COMM_WITH_PPCALL`: Represents inlets through which notifications can be
      sent and protected procedure calls can be made across a channel.
    - `IRQ`: Represents inlets that lead to interrupt request (IRQ) channels:
      notifications or porotected procedure calls cannot be made through such
      channels; however, they can be used to acknowledge the corresponding IRQ.
    """
    COMM_WITHOUT_PPCALL = 1
    COMM_WITH_PPCALL = 2
    IRQ = 3

class InletCap:
    """
    Provides methods for emitting code regarding capabilities associated
    with a specific inlet of the target protection domain.

    This includes methods to generate names for the types related to the inlet
    and to generate specific Austral output lines related to the capability type.

    Attributes
    ----------
    number : int
        The inlet number associated with the capability.
    sort : InletSort
        The sort of the inlet, represented as an instance of the InletSort enumeration.

    Methods
    -------
    chname() -> str:
        Returns the generated Austral name of this inlet.

    capname() -> str:
        Returns the name of the generated Austral capability type associated with the inlet.

    irqname() -> str:
        Returns the name of the generated Austral IRQ type associated with the inlet.

    callname() -> str:
        Returns the name of the generated Austral call source constructor associated with the inlet.

    mintname() -> str:
        Returns the name of the generated Austral mint function associated with the inlet.

    constructorexpr() -> str:
        Returns the Austral expression used to construct an instance of the NotificationSource
        associated with the inlet.

    make_all(emit: Emitter) -> None:
        Generates and adds the comprehensive code pertaining specifically to this inlet
        to the given emitter's output lists.
    """
    def __init__(self, number: int, sort: InletSort) -> None:
        self.number = number
        self.sort = sort

    def chname(self) -> str:
        """
        Return the generated Austral name of this inlet.

        This name has the form ChXX where XX is the inlet number (prefixed with a leading
        zero if the inlet number is below 10).

        This name is used as a constructor name in the generated code when referring to the
        inlet as a notification source, and is used as part of the name in all other names
        relating to this inlet.

        Returns
        -------
        str
            The Austral name of the inlet.
        """
        if self.number < 10:
            return "Ch0%s" % self.number
        return "Ch%s" % self.number

    def capname(self) -> str:
        """
        Return the name of the generated Austral capability type associated with the inlet.

        This name is used in the generated code as the name of the capability type associated
        with the inlet. The holder of such a capability can send notifications, make protected
        procedure calls, and do any and all other operations available on this inlet.

        Returns
        -------
        str
            The name of the Austral capability type associated with the inlet.
        """
        return "%sCap" % self.chname()

    def irqname(self) -> str:
        """
        Return the name of the generated Austral IRQ type associated with the inlet.

        This name is used in the generated code as the name of the IRQ type associated
        with the inlet. The holder of such a capability can acknowledge (or explicitly
        postpone acknowledging) the IRQ associated with the other end of this inlet.

        Returns
        -------
        str
            The name of the Austral IRQ type associated with the inlet.
        """
        return "%sIrq" % self.chname()

    def callname(self) -> str:
        """
        Return the name of the generated Austral call source constructor associated with the inlet.

        This name is used as a constructor name in the generated code when referring to the
        inlet as a protected procedure call source. It needs to differ from the chname, which
        is used as the constructor for notification sources.

        Returns
        -------
        str
            The name of the Austral call source constructor associated with the inlet.
        """
        return "From%s" % self.chname()

    def mintname(self) -> str:
        """
        Return the name of the generated Austral mint function associated with the inlet.

        This name is used as a function name in the generated code when referring to the
        function that allows the holder of a MantleUserCap to mint instances of the
        capability type associated with this inlet.

        Returns
        -------
        str
            The name of the Austral mint function associated with the inlet.
        """
        return "mint%s" % self.chname()

    def constructorexpr(self) -> str:
        """
        Return the Austral expression used to construct an instance of the NotificationSource
        associated with the inlet.

        Returns
        -------
        str
            The Austral expression that constructs an instance of the NotificationSource
            associated with the inlet.
        """
        if self.sort == InletSort.IRQ:
            return "%s(irq => %s())" % (self.chname(), self.irqname())
        return "%s()" % self.chname()

    def make_all(self, emit: Emitter) -> None:
        """
        Generate and add the comprehensive code pertaining specifically to this inlet
        to the given emitter's output lists.

        The method is responsible for creating the different Austral type, instance
        and function declarations, including the inlet's ChXXCap type, its Notifiable,
        Callable instances, the mintChXX function, and if needed the ChXXIrq type
        and its Ackable instance. It is not responsible for creating types and
        functions that depend on all available inlets, such as NotificationSource.
        
        All the code blocks are added to  the 'aui' and 'aum' outputs of the given
        Emitter object, which will be written to the corresponding files later.

        The specific code generated depends on the type of inlet (`InletSort`). E.g., 
        if the inlet is not of sort `InletSort.IRQ`, then no ChXXIrq type is generated.

        Parameters
        ----------
        emit : Emitter
            The Emitter object to which the generated code is to be added.
        """
        emit.indentation_aui = "    "
        emit.indentation_aum = "    "

        emit.aui( "-- BEGIN generated code for inlet %s --" % self.number )
        emit.aum( "-- BEGIN generated code for inlet %s --" % self.number )

        self.make_cap_type(emit);
        self.make_mint_function(emit);
        self.make_surrenderable_instance(emit);

        if self.sort == InletSort.IRQ:
            self.make_irq_type(emit)
            self.make_ackable_irq_instance(emit)
        else:
            self.make_notifiable_instance(emit);

        if self.sort == InletSort.COMM_WITH_PPCALL:
            self.make_callable_instance(emit);

        emit.aui( "-- END generated code for inlet %s --\n" % self.number )
        emit.aum( "-- END generated code for inlet %s --\n" % self.number )

    def make_cap_type(self, emit: Emitter) -> None:
        emit.indentation_aui = "    ";
        emit.indentation_aum = "    ";
        
        emit.aui( "type %s: Linear;" % self.capname() )
        
        emit.aum( "record %s: Linear is" % self.capname() )
        emit.aum( "end;" )

    def make_irq_type(self, emit: Emitter) -> None:
        emit.indentation_aui = "    ";
        emit.indentation_aum = "    ";
        
        emit.aui( "type %s: Linear;" % self.irqname() )
        
        emit.aum( "record %s: Linear is" % self.irqname() )
        emit.aum( "end;" )

    def make_mint_function(self, emit: Emitter) -> None:
        emit.indentation_aui = "    ";
        emit.indentation_aum = "    ";
        
        emit.aui( "generic [R: Region]" )
        emit.aui( "function %s(cap: &[MantleUserCap, R]): %s;" % (self.mintname(), self.capname()) )

        emit.aum( "generic [R: Region]" )
        emit.aum( "function %s(cap: &[MantleUserCap, R]): %s is" % (self.mintname(), self.capname()) )
        emit.aum( "    return %s();" % self.capname() )
        emit.aum( "end;" )

    def make_surrenderable_instance(self, emit: Emitter) -> None:
        emit.indentation_aui = "    ";
        emit.indentation_aum = "    ";

        emit.aui( "instance Surrenderable(%s); " % self.capname() )
        emit.aum( "instance Surrenderable(%s) is" % self.capname() )
        emit.aum( "    method surrender(cap: %s): Unit is" % self.capname() )
        emit.aum( "        let { } := cap;" )
        emit.aum( "        return nil;" )
        emit.aum( "    end;" )
        emit.aum( "end;" )

    def make_notifiable_instance(self, emit: Emitter) -> None:
        emit.indentation_aui = "    ";
        emit.indentation_aum = "    ";

        emit.aui( "instance Notifiable(%s); " % self.capname() )
        emit.aum( "instance Notifiable(%s) is" % self.capname() )
        emit.aum( "    generic [R: Region]" )
        emit.aum( "    method notify(cap: &[%s,R]): Unit is" % self.capname() )
        emit.aum( "        unsafeNotify(%s);" % self.number )
        emit.aum( "        return nil;" )
        emit.aum( "    end;" )
        emit.aum( "end;" )

    def make_callable_instance(self, emit: Emitter) -> None:
        emit.indentation_aui = "    ";
        emit.indentation_aum = "    ";

        emit.aui( "instance Callable(%s); " % self.capname() )
        emit.aum( "instance Callable(%s) is" % self.capname() )
        emit.aum( "    generic [R: Region]" )
        emit.aum( "    method ppcall(cap: &[%s,R], tag: MessageInfo): MessageInfo is" % self.capname() )
        emit.aum( "        let ret_label: Nat64 := unsafePpcall(%s, tag.label, tag.count);" % self.number)
        emit.aum( "        let ret_count: Nat16 := unsafeRetCount();")
        emit.aum( "        return MessageInfo(label => ret_label, count => ret_count);")
        emit.aum( "    end;" )
        emit.aum( "end;" )

    def make_ackable_irq_instance(self, emit: Emitter) -> None:
        emit.indentation_aui = "    ";
        emit.indentation_aum = "    ";

        emit.aui( "instance Ackable(%s); " % self.irqname() )
        emit.aum( "instance Ackable(%s) is" % self.irqname() )
        emit.aum( "    method acknowledge(cap: %s): Unit is" % self.irqname() )
        emit.aum( "        unsafeIrqAck(%s);" % self.number )
        emit.aum( "        let { } := cap;" )
        emit.aum( "        return nil;" )
        emit.aum( "    end;" )
        emit.aum( "    method postpone(cap: %s): Unit is" % self.irqname() )
        emit.aum( "        let { } := cap;" )
        emit.aum( "        return nil;" )
        emit.aum( "    end;" )
        emit.aum( "end;" )


@dataclass(frozen=True, eq=True)
class InletCodeBuilder:
    """
    A class providing methods for emitting code related to all inlet capabilities of a system.

    This class takes as input a collection of `InletCap` objects, and generates code based on
    the sort of each. Additionally, it generates code that is common to all inlets, such as
    NotificationSource, PpcallSource.

    The generated code is added to the 'aui' and 'aum' outputs of the `Emitter` object, which
    will be written to the corresponding files later.

    Parameters
    ----------
    inlet_caps : tuple[InletCap, ...]
        The tuple of `InletCap` objects for which the code is to be generated.

    Methods
    -------
    make_all(emit: Emitter) -> None:
        Generates and adds the comprehensive code for all inlets to the given emitter's output lists.
    """
    inlet_caps: tuple[InletCap, ...]

    def make_all(self, emit: Emitter) -> None:
        """
        Generate and add the comprehensive code for all inlets to the given emitter's output lists.

        This includes emitting the inlet-specific definitions provided by the InletCap class,
        and the code that depends on all inlets, such as notification source types and
        protected procedure call source types.

        Parameters
        ----------
        emit : Emitter
            The Emitter object to which the generated code is to be added.
        """
        for ic in self.inlet_caps:
            ic.make_all(emit)
        emit.indentation_aui = "    "
        emit.indentation_aum = "    "
        emit.aui( "-- BEGIN generated code common to all inlets --" )
        emit.aum( "-- BEGIN generated code common to all inlets --" )

        self.make_notification_source_type(emit)
        self.make_get_notification_source_function(emit)
        self.make_ppcall_source_type(emit)
        self.make_get_ppcall_source_function(emit)

        emit.aui( "-- END generated code common to all inlets --\n" )
        emit.aum( "-- END generated code common to all inlets --\n" )

    def make_notification_source_type(self, emit: Emitter) -> None:
        emit.indentation_aui = "    "
        emit.aui( "union NotificationSource: Linear is" )

        emit.indentation_aui = "       "
        for ic in self.inlet_caps:
            if ic.sort == InletSort.IRQ:
                emit.aui( "case %s is" % ic.chname() )
                emit.aui( "    irq: %s;" % ic.irqname() )
            else:
                emit.aui( "case %s;" % ic.chname() )
        emit.aui( "case UnknownNotification is" )
        emit.aui( "    number: Nat32;" )

        emit.indentation_aui = "    "
        emit.aui( "end;" )

    def make_ppcall_source_type(self, emit: Emitter) -> None: 
        emit.indentation_aui = "    "
        emit.aui( "union PpcallSource: Linear is" )

        emit.indentation_aui = "       "
        for ic in self.inlet_caps:
            if ic.sort == InletSort.COMM_WITHOUT_PPCALL:
                emit.aui( "case %s;" % ic.callname() )
        emit.aui( "case UnknownPpcall is" )
        emit.aui( "    number: Nat64;" )

        emit.indentation_aui = "    "
        emit.aui( "end;" )

    def make_get_notification_source_function(self, emit: Emitter) -> None:
        emit.indentation_aui = "    ";
        emit.indentation_aum = "    ";

        emit.aui( "generic [R: Region]" )
        emit.aui( "function getNotificationSource(cap: &[MantleSystemCap, R], idx: Nat32): NotificationSource;" )

        emit.aum( "generic [R: Region]" )
        emit.aum( "function getNotificationSource(cap: &[MantleSystemCap, R], idx: Nat32): NotificationSource is" )
        if self.inlet_caps:
            emit.indentation_aum = "        "
            emit.aum( "if idx = %s then" % self.inlet_caps[0].number )
            emit.aum( "    return %s;" % self.inlet_caps[0].constructorexpr() )
            for ic in self.inlet_caps[1:]:
                emit.aum( "else if idx = %s then" % ic.number )
                emit.aum( "    return %s;" % ic.constructorexpr() )
            emit.aum( "else" )
            emit.aum( "    return UnknownNotification(number => idx);" )
            emit.aum( "end if;" )
            emit.indentation_aum = "    "
        else:
            emit.aum( "    return UnknownNotification(number => idx);" )
        emit.aum( "end;" )

    def make_get_ppcall_source_function(self, emit: Emitter) -> None:
        emit.indentation_aui = "    ";
        emit.indentation_aum = "    ";

        emit.aui( "generic [R: Region]" )
        emit.aui( "function getPpcallSource(cap: &[MantleSystemCap, R], idx: Nat64): PpcallSource;" )

        emit.aum( "generic [R: Region]" )
        emit.aum( "function getPpcallSource(cap: &[MantleSystemCap, R], idx: Nat64): PpcallSource is" )
        inlet_ppcall_caps: list[InletCap] = \
          [ic for ic in self.inlet_caps if ic.sort == InletSort.COMM_WITHOUT_PPCALL]
        if inlet_ppcall_caps:
            emit.indentation_aum = "        "
            emit.aum( "if idx = %s then" % inlet_ppcall_caps[0].number )
            emit.aum( "    return %s();" % inlet_ppcall_caps[0].callname() )
            for ic in inlet_ppcall_caps[1:]:
                emit.aum( "else if idx = %s then" % ic.number )
                emit.aum( "    return %s();" % ic.callname() )
            emit.aum( "else" )
            emit.aum( "    return UnknownPpcall(number => idx);" )
            emit.aum( "end if;" )
            emit.indentation_aum = "    "
        else:
            emit.aum( "    return UnknownPpcall(number => idx);" )
        emit.aum( "end;" )


def canonical_austral_name(name: str) -> str:
    parts = name.split('_')
    parts = [part.capitalize() for part in parts]
    result: str = ''.join(parts)
    if len(result) < 1:
        # canonical names for all-underscore teens
        result = 'X%s' % len(name)
    return result

@dataclass(frozen=True, eq=True)
class MemoryCap:
    """
    Provides methods for emitting code regarding capabilities associated
    with mapped memory regions of the target protection domain.

    This includes methods to generate names for the types related to the mapped
    memory region, and to generate specific Austral output lines related to the
    capability types and Span types associated with it.

    Attributes
    ----------
    name : str
        the name of this memory region as specified by the user in the SDF
    address : int
        the virtual address at which the given memory region starts
    size : int
        the size of the memory region in smallest addressable units
    writable : bool
        True precisely if the memory region is mapped to the current protection
        domain with write permissions
    patch_symbol : Optional[str]
        the variable/symbol name in the final executable into which the address
        will be patched by the sel4cp_tool using the setvar mechanism (if any)

    Methods
    -------
    basename() -> str:
        Returns the generated Austral name of this memory region.

    fieldname() -> str:
        Returns the name of the generated field in the MemoryCaps record
        associated with this memory region.

    rwcapname() -> str:
        Returns the name of the generated Austral capability type that allows one
        to read and write to this memory region.

    rcapname() -> str:
        Returns the name of the generated Austral capability type that allows one
        to read from (but not write to) this memory region.

    topcapname() -> str:
        Returns the name of the generated Austral capability type that grants the
        highest available permissions to this memory region (read-write or read).

    patchname_c() -> str:
        Returns the name of the generated C function that returns the addresss of
        this memory region.

    patchname_aum() -> str:
        Returns the name of the generated Austral function that returns the addresss of
        this memory region.

    initexpr() -> str:
        Returns the Austral expression used to initialize the capability associated
        with this memory region when constructing an instance of MemoryCaps.

    make_all(emit: Emitter) -> None:
        Generates and adds the comprehensive code pertaining specifically to this memory region
        to the given emitter's output lists.
    """
    name: str
    address: int
    size: int
    writable: bool
    patch_symbol: Optional[str]

    def basename(self) -> str:
        """
        Return the generated Austral name of this memory region.

        This name is based on the patch symbol name given by the user in the SDF
        for the mapped memory region in this protection domain. For example, a
        memory region that has the setvar name hello_ptr in the SDF will have
        the base name HelloPtr. If no patch symbol name was provided, a default
        name is generated based on the SDF-declared named of the memory region
        itself.

        This name is used as part of the name in all other names
        relating to this mapped memory region.

        Returns
        -------
        str
            The Austral name of the memory region.
        """
        if self.patch_symbol:
            return canonical_austral_name(self.patch_symbol)
        return canonical_austral_name(self.name)

    def fieldname(self) -> str:
        """
        Return the name of the generated field in the MemoryCaps record
        associated with this memory region.

        This is the name used to access the field of this memory region
        in the MemoryCaps record. For example, the setvar name hello_ptr
        will result in the field `helloPtr: HelloPtr` in MemoryCaps.

        Returns
        -------
        str
            The Austral name of the field of the memory region.
        """
        result = self.basename()
        return result[0].lower() + result[1:]

    def rwcapname(self) -> str:
        """
        Return the name of the generated Austral capability type that allows one
        to read and write to this memory region.

        Returns
        -------
        str
            The Austral name of the RW cap to the memory region.
        """
        return "%sRWCap" % self.basename()

    def rcapname(self) -> str:
        """
        Return the name of the generated Austral capability type that allows one
        to read from (but not write to) this memory region.

        Returns
        -------
        str
            The Austral name of the R cap to the memory region.
        """
        return "%sRCap" % self.basename()

    def topcapname(self) -> str:
        """
        Return the name of the generated Austral capability type that grants the
        highest available permissions to this memory region (read-write or read).

        This is the name of the RW cap if the memoru is mapped writable, and the
        R cap otherwise.

        Returns
        -------
        str
            The Austral name of the highest permission cap to the memory region.
        """
        if self.writable:
            return self.rwcapname()
        return self.rcapname()

    def patchname_c(self) -> str:
        """
        Return the name of the generated C function that returns the addresss of
        this memory region.

        This name is based on the patch symbol name given by the user in the SDF.
        If no patch symbol name was provided, a default name is generated based
        on the SDF-declared named of the memory region itself.

        Returns
        -------
        str
            The C name of the address function for this memory region.
        """
        name: str = self.name
        if self.patch_symbol:
            name = self.patch_symbol
        return "mantle_generated_get_%s" % name

    def patchname_aum(self) -> str:
        """
        Return the name of the generated Austral function that returns the
        addresss of this memory region.

        This function is unsafe (it calls an External_Name), so not exported in
        the public generated interface.

        Returns
        -------
        str
            The Austral name of the address function for this memory region.
        """
        return "unsafeGet%s" % self.basename()

    def initexpr(self) -> str:
        """
        Return the Austral expression used to initialize the capability associated
        with this memory region when constructing an instance of MemoryCaps.
        
        Returns
        -------
        str
            The Austral expression used to initialize the capability in MemoryCaps.
        """
        return "%s => %s()" % (self.fieldname(), self.topcapname())

    def make_all(self, emit: Emitter) -> None:
        """
        Generate and add the code for a memory region to the emitter's output lists.

        This method is responsible for creating the different Austral type, instance and
        function declarations, including the mapped memory region's read and read-write
        capability types, its Readable and Writable instances, and (if required) the
        demotion function which converts read-write to read capabilities. It is not
        responsible for creating types that depend on all available memory regions,
        such as the MemoryCaps record.
        
        All the code blocks are added to the 'c', 'aui' and 'aum' outputs of the given
        Emitter object, which will be written to the corresponding files later.

        Parameters
        ----------
        emit : Emitter
            The Emitter object to which the generated code is to be added.
        """
        emit.indentation_c = ""
        emit.indentation_aui = "    "
        emit.indentation_aum = "    "

        emit.c( "/* BEGIN generated code for memory region %s */" % self.basename() )
        emit.aui( "-- BEGIN generated code for memory region %s --" % self.basename() )
        emit.aum( "-- BEGIN generated code for memory region %s --" % self.basename() )
        if self.writable:
            self.make_read_write_cap_type(emit)
            self.make_read_write_cap_surrenderable_instance(emit)

        self.make_read_cap_type(emit)
        self.make_read_cap_surrenderable_instance(emit)

        self.make_get_function(emit)

        if self.writable:
            self.make_to_read_cap_function(emit)
            self.make_writable_instance(emit)
        self.make_readable_instance(emit)
        emit.c( "/* END generated code for memory region %s */\n" % self.basename() )
        emit.aui( "-- END generated code for memory region %s --\n" % self.basename() )
        emit.aum( "-- END generated code for memory region %s --\n" % self.basename() )

    def make_read_write_cap_type(self, emit: Emitter) -> None:
        emit.indentation_aui = "    "
        emit.indentation_aum = "    "

        emit.aui( "type %s: Linear;" % self.rwcapname() )
        emit.aum( "record %s: Linear is" % self.rwcapname() )
        emit.aum( "end;" )

    def make_read_cap_type(self, emit: Emitter) -> None:
        emit.indentation_aui = "    "
        emit.indentation_aum = "    "

        emit.aui( "type %s: Linear;" % self.rcapname() )
        emit.aum( "record %s: Linear is" % self.rcapname() )
        emit.aum( "end;" )

    def make_read_write_cap_surrenderable_instance(self, emit: Emitter) -> None:
        emit.indentation_aui = "    ";
        emit.indentation_aum = "    ";

        emit.aui( "instance Surrenderable(%s); " % self.rwcapname() )
        emit.aum( "instance Surrenderable(%s) is" % self.rwcapname() )
        emit.aum( "    method surrender(cap: %s): Unit is" % self.rwcapname() )
        emit.aum( "        let { } := cap;" )
        emit.aum( "        return nil;" )
        emit.aum( "    end;" )
        emit.aum( "end;" )

    def make_read_cap_surrenderable_instance(self, emit: Emitter) -> None:
        emit.indentation_aui = "    ";
        emit.indentation_aum = "    ";

        emit.aui( "instance Surrenderable(%s); " % self.rcapname() )
        emit.aum( "instance Surrenderable(%s) is" % self.rcapname() )
        emit.aum( "    method surrender(cap: %s): Unit is" % self.rcapname() )
        emit.aum( "        let { } := cap;" )
        emit.aum( "        return nil;" )
        emit.aum( "    end;" )
        emit.aum( "end;" )

    def make_to_read_cap_function(self, emit: Emitter) -> None:
        emit.indentation_aui = "    "
        emit.indentation_aum = "    "

        emit.aui( "function to%s(cap: %s): %s;" % (self.rcapname(), self.rwcapname(), self.rcapname()) )
        emit.aum( "function to%s(cap: %s): %s is" % (self.rcapname(), self.rwcapname(), self.rcapname()) )
        emit.aum( "   let { } := cap; ")
        emit.aum( "   return %s(); " % self.rcapname() )
        emit.aum( "end;" )

    def make_get_function(self, emit: Emitter) -> None:
        emit.indentation_c = ""
        emit.indentation_aum = "    "

        if self.patch_symbol:
            emit.c( "uint64_t %s;" % self.patch_symbol )
        emit.c( "uint64_t %s() {" % self.patchname_c() )
        if self.patch_symbol:
            emit.c( "  return %s;" % self.patch_symbol )
        else:
            emit.c( "  return %s;" % self.address )
        emit.c("}")

        if self.patch_symbol:
            emit.aum( "pragma Foreign_Import(External_Name => \"%s\");" % self.patchname_c())
            emit.aum( "function %s(): Nat64 is" % self.patchname_aum() )
            emit.aum( "end;" )

    def make_readable_instance(self, emit: Emitter) -> None:
        emit.indentation_aui = "    ";
        emit.indentation_aum = "    ";

        emit.aui( "instance Readable(%s); " % self.rcapname() )

        if self.patch_symbol:
            emit.aum( "instance Readable(%s) is" % self.rcapname() )
            emit.aum( "    generic [R: Region]" )
            emit.aum( "    method toSpan(cap: &[%s,R]): Span[Nat8, R] is" % self.rcapname() )
            emit.aum( "        let address: Nat64 := %s();" % self.patchname_aum() )
            emit.aum( "        return unsafeMakeSpan(address,%s);" % self.size )
            emit.aum( "    end;" )
            emit.aum( "end;" )
        else:
            emit.aum( "instance Readable(%s) is" % self.rcapname() )
            emit.aum( "    generic [R: Region]" )
            emit.aum( "    method toSpan(cap: &[%s,R]): Span[Nat8, R] is" % self.rcapname() )
            emit.aum( "        return unsafeMakeSpan(%s,%s);" % (self.address, self.size) )
            emit.aum( "    end;" )
            emit.aum( "end;" )

    def make_writable_instance(self, emit: Emitter) -> None:
        emit.indentation_aui = "    "
        emit.indentation_aum = "    "

        emit.aui( "instance Writable(%s); " % self.rwcapname() )

        if self.patch_symbol:
            emit.aum( "instance Writable(%s) is" % self.rwcapname() )
            emit.aum( "    generic [R: Region]" )
            emit.aum( "    method toSpanWrite(cap: %s): Span![Nat8, R] is" % self.rwcapname() )
            emit.aum( "        let { } := cap;" )
            emit.aum( "        let address: Nat64 := %s();" % self.patchname_aum() )
            emit.aum( "        return unsafeMakeSpanWrite(address,%s);" % self.size )
            emit.aum( "    end;" )
            emit.aum( "end;" )
        else:
            emit.aum( "instance Writable(%s) is" % self.rwcapname() )
            emit.aum( "    generic [R: Region]" )
            emit.aum( "    method toSpanWrite(cap: %s): Span![Nat8, R] is" % self.rwcapname() )
            emit.aum( "        let { } := cap;" )
            emit.aum( "        return unsafeMakeSpanWrite(%s,%s);" % (self.address, self.size) )
            emit.aum( "    end;" )
            emit.aum( "end;" )


@dataclass(frozen=True, eq=True)
class MemoryCodeBuilder:
    """
    A class providing methods for emitting code related to all mapped memory region capabilities
    of a protection domain.

    This class takes as input a collection of `MemoryCap` objects, and generates code based on
    each memory region described in this collection. Additionally, it generates code that is
    common to all memory regions, such as the MemoryCaps type.

    The generated code is added to the 'c', 'aui' and 'aum' outputs of the `Emitter` object, which
    will be written to the corresponding files later.

    Parameters
    ----------
    memory_caps : tuple[MemoryCap, ...]
        The tuple of `MemoryCap` objects for which the code is to be generated.

    Methods
    -------
    make_all(emit: Emitter) -> None:
        Generates and adds the comprehensive code for all mapped memory regions to the
        given emitter's output lists.
    """
    memory_caps: tuple[MemoryCap, ...]

    def make_all(self, emit: Emitter) -> None:
        """
        Generate and add the comprehensive code for all mapped memory regions to the
        given emitter's output lists.

        This includes emitting the region-specific definitions provided by the MemoryCap class,
        and the code that depends on all memory regions of the protection domain, such as
        the MemoryCaps record.

        Parameters
        ----------
        emit : Emitter
            The Emitter object to which the generated code is to be added.
        """
        for memory_cap in self.memory_caps:
            memory_cap.make_all(emit)
        emit.indentation_aui = "    "
        emit.indentation_aum = "    "
        emit.aui( "-- BEGIN generated code common to all memory regions --" )
        emit.aum( "-- BEGIN generated code common to all memory regions --" )

        self.make_memory_caps_type(emit)
        self.make_mint_function(emit)
        self.make_surrenderable_instance(emit)

        emit.aui( "-- END generated code common to all memory regions --\n" )
        emit.aum( "-- END generated code common to all memory regions --\n" )

    def make_memory_caps_type(self, emit: Emitter) -> None:
        emit.indentation_aui = "    "
        emit.indentation_aum = "    "

        emit.aui( "record MemoryCaps: Linear is" )
        emit.indentation_aui = "       "
        for memory_cap in self.memory_caps:
            emit.aui( "%s: %s;" % (memory_cap.fieldname(), memory_cap.topcapname()) )
        emit.indentation_aui = "    "
        emit.aui( "end;" )

    def make_mint_function(self, emit: Emitter) -> None:
        emit.indentation_aui = "    "
        emit.indentation_aum = "    "
        emit.aui( "generic [R: Region]" )
        emit.aui( "function mintMemoryCaps(cap: &[MantleSystemCap, R]): MemoryCaps;" )

        emit.aum( "generic [R: Region]" )
        emit.aum( "function mintMemoryCaps(cap: &[MantleSystemCap, R]): MemoryCaps is" )
        field_initialization: str = \
          ", ".join([memory_cap.initexpr() for memory_cap in self.memory_caps])
        emit.aum( "    return MemoryCaps(%s);" % field_initialization )
        emit.aum( "end;" )

    def make_surrenderable_instance(self, emit: Emitter) -> None:
        emit.indentation_aui = "    ";
        emit.indentation_aum = "    ";

        emit.aui( "instance Surrenderable(MemoryCaps); " )
        emit.aum( "instance Surrenderable(MemoryCaps) is" )
        emit.aum( "    method surrender(cap: MemoryCaps): Unit is" )
        emit.indentation_aum = "           ";
        fields: list[str] = \
          ["%s: %s" % (memory_cap.fieldname(), memory_cap.topcapname()) for memory_cap in self.memory_caps ]
        field_destruction: str = \
          ", ".join(fields)
        emit.aum( "let { %s } := cap;" % field_destruction )
        for memory_cap in self.memory_caps:
            emit.aum( "let { } := %s;" % memory_cap.fieldname() )
        emit.aum( "return nil;" )
        emit.indentation_aum = "    ";
        emit.aum( "    end;" )
        emit.aum( "end;" )

def make_headers(emit: Emitter) -> None:
    emit.indentation_aui = ""
    emit.aui( "-- This file was generated automatically by mantle_tool. Do not modify! --")
    emit.aui( "import Mantle.Common (" )
    emit.aui( "    Notifiable, Callable, Ackable," )
    emit.aui( "    Surrenderable, Readable, Writable," )
    emit.aui( "    MantleSystemCap, MantleUserCap," )
    emit.aui( "    MessageInfo" )
    emit.aui( ");\n" )
    emit.aui("module Mantle.Generated is")

    emit.indentation_aum = ""
    emit.aum( "-- This file was generated automatically by mantle_tool. Do not modify! --")
    emit.aum( "pragma Unsafe_Module;\n" )
    emit.aum( "import Mantle.Common (" )
    emit.aum( "    Notifiable, Callable, Ackable," )
    emit.aum( "    Surrenderable, Readable, Writable," )
    emit.aum( "    MantleSystemCap, MantleUserCap," )
    emit.aum( "    MessageInfo" )
    emit.aum( ");\n" )

    emit.aum( "import Mantle.Unsafe (" )
    emit.aum( "    unsafeNotify, unsafePpcall, unsafeIrqAck," )
    emit.aum( "    unsafeRetCount, unsafeMakeSpan, unsafeMakeSpanWrite" )
    emit.aum( ");\n" )

    emit.aum("module body Mantle.Generated is")

    emit.indentation_c = ""
    emit.c( "/* This file was generated automatically by mantle_tool. Do not modify! */" )
    emit.c( "#include <stddef.h>" )
    emit.c( "#include <stdint.h>" )
    emit.c( "#include \"libmantle.h\"" )

def make_footers(emit: Emitter) -> None:
    emit.indentation_aui = ""
    emit.indentation_aum = ""
    emit.aui("end module.")
    emit.aum("end module body.")

def generate_api(the_registry: Registry, the_protection_domain: ProtectionDomain) -> Emitter:
    """
    Generates and returns an Austral programming language API based on the seL4 Core Platform
    system specification given in the Registry.

    This function creates an API interface for a specified protection domain.
    It first identifies the relevant inlets and memory regions for the given protection domain
    from the registry, then uses an `Emitter` object to generate the corresponding code for all
    the inlet and memory capabilities and adds the headers and footers.

    The final `Emitter` object is then returned, which can be used to output the generated code
    to the corresponding files later.

    Parameters
    ----------
    the_registry : Registry
        The registry object derived from a user-provided SDF system description file that
        contains the system specification.

    the_protection_domain : ProtectionDomain
        The protection domain for which the API is to be generated.

    Returns
    -------
    Emitter
        The Emitter object that contains the generated API code for the specified protection domain.
    """
    current_pd: ProtectionDomain = the_protection_domain
    inlet_caps: list[InletCap] = list()

    # 1. gather all inlets that will appear in the generated interface
    target_inlets: list[Inlet] = \
      [i for i in the_registry.inlets if i.protection_domain == current_pd]
    target_inlets.sort(key=lambda x: x.number)
    for current_inlet in target_inlets:

        # check if this inlet leads to a communication channel
        other_ends: list[frozenset[Inlet]] = \
          [cc.inlets - set([current_inlet]) for cc in the_registry.comm_channels if current_inlet in cc.inlets ]
        if other_ends:
            # this is a comm channel
            other_end: Inlet = list(other_ends[0])[0]
            other_pd: ProtectionDomain = other_end.protection_domain
            callable = \
              the_registry.priority_by_protection_domain[current_pd] < \
              the_registry.priority_by_protection_domain[other_pd]
            callable = \
              callable and (other_pd in the_registry.protection_domains_providing_ppcall)
            comm_cap_sort: InletSort = \
              InletSort.COMM_WITH_PPCALL if callable else InletSort.COMM_WITHOUT_PPCALL
            comm_cap: InletCap = InletCap(current_inlet.number, comm_cap_sort)
            inlet_caps.append(comm_cap)

        # check if this inlet leads to an IRQ channel
        irq_ends: list[int] = \
          [ic.irq for ic in the_registry.irq_channels if ic.inlet == current_inlet]
        if irq_ends:
            # this is an IRQ channel
            irq_end: int = irq_ends[0]
            irq_cap: InletCap = InletCap(current_inlet.number, InletSort.IRQ)
            inlet_caps.append(irq_cap)

    # 2. gather all memory regions that will appear in the generated interface
    target_mmrs: list[MappedMemoryRegion] = \
      [mmr for mmr in the_registry.mapped_memory_regions if mmr.protection_domain == current_pd]

    memory_caps: list[MemoryCap] = list()
    for mmr in target_mmrs:
        memory_caps.append(MemoryCap(mmr.name, mmr.address, mmr.size, mmr.writable, mmr.patch_symbol))

    # 3. emit code
    emit: Emitter = Emitter()
    make_headers(emit)
    InletCodeBuilder(tuple(inlet_caps)).make_all(emit)
    MemoryCodeBuilder(tuple(memory_caps)).make_all(emit)
    make_footers(emit)
    return emit
