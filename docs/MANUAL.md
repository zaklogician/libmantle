<!--
    Copyright 2023, COMAS (ABN 11 932 720 318) and the project contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->

# The libmantle manual v0.1.0

## Introduction

libmantle is an experimental library and SDK designed to let you write
applications in the Austral programming language that run on the seL4 Core
Platform.

The seL4 Core Platform is a framework for static and embedded applications,
built on the seL4 microkernel. While the platform is powerful, its C API can
result in runtime faults if not properly handled.

The libmantle SDK reads your System Description File and generates an Austral
API that leverages the language's linear type system to statically prevent any
runtime faults produced by the seL4 Core Platform API, and prevents other
common seL4 programming errors, such as forgetting to acknowledge IRQs.

This manual assumes familiarity with the rudiments of the Austral language, and
working knowledge of the seL4 Core Platform abstractions (protection domains,
meory regions, communication channel, IRQs). To learn more, see the

* [Austral specification](https://austral-lang.org/spec/),
* [seL4 Core Platform manual](https://github.com/BreakawayConsulting/sel4cp/blob/main/docs/manual.md),
* videos by [Gernot Heiser](https://www.youtube.com/watch?v=khcjH77riGA) and [Zoltan Kocsis](https://www.youtube.com/watch?v=kRI4VQRSB_w) on the seL4 Core Platform.


## Components

The libmantle SDK comprises two distinct parts: the library and the mantle-tool
program.

### Library

The library component is housed in the `library/` directory and is written in
Austral. It is a relatively thin wrapper on the seL4 Core Platform, and
provides Austral versions of the common data structures used by seL4CP, such as
`MessageInfo` structures.

Furthermore, it exposes type classes and methods corresponding to various system
functions. For instance, the library provides a safe equivalent to the seL4 Core
Platform's `sel4cp_notify(..)` function in the form of the `Notifiable` type
class and its `notify(-)` method.

The safety of these methods is ensured as the library only allows for the
invocation of system functions in ways that prevent runtime faults. It achieves
this by regulating the generated API to exclude capabilities that could lead to
incorrect or illegal invocations according to the System Description Format.

### mantle-tool

The `mantle-tool` program, residing in the `mantle-tool/` directory, is a
Python-based tool that translates the System Description File into a type-safe,
runtime-fault-safe Austral API.

For example, if two Protection Domains have a communication channel between
them, the tool will ensure that the API allows for mutual notification by
generating capability types that implement the `Notifiable` type class.

Similarly, the tool knows about and respects the priority rules of the seL4
Core Platform, and will only allow protected procedure calls from
lower-priority to the higher-priority domains: this ensures that the generated
systems are deadlock-free.

The API generated by the mantle-tool is intended to be used alongside the
library by the developers implementing their Protection Domains, effectively
enabling them to write their programs that run on the seL4 Core Platform
in a safe and structured manner.

### Dependencies

The primary dependency for using libmantle is Python itself. Note that there
are separate instructions provided for installation in the main README file.


## Using mantle-tool

The `mantle-tool` program is a Python program found in the `mantle-tool/`
directory. It serves as the API generator for libmantle. Its primary role
is to convert a system description file into three essential files:
a C header file, an Austral interface, and an Austral module. These files form
the backbone of the safe API you will use when implementing your protection
domains.

### Generated files

* **C Header**: This file ensures seamless interoperability with the seL4 Core
                Platform. It includes the `libsel4cp` and `libmantle` headers,
                and guarantees that the compiled ELF binary will contain the
                correct symbol names expected by the seL4 Core Platform tool.

* **Austral Interface**: The actual API you will interact with when
  implementing your protection domain. The interface encapsulates various
  types that correspond to channels and memory regions your protection domain
  has access to. For instance, if you have writable access to a memory region
  `mem_reg`, the generated interface will expose a `MemRegRWCap`, allowing you
  to read from and write to the `mem_reg` region. Channel capabilities, such
  as Ch05Cap, are also defined, which lets you perform operations like
  notifying on your channel 5.

* **Austral Module**: This file contains the implementation of the API itself.

### Using Capabilities

The generated Austral interface is your point of contact: it gives you an
overview of precisely which types and capabilities were issued based on your
system description. For example, if your protection domain is connected through
channel 6 to another protection domain capable of handling protected procedure
calls, the generated API will contain a `Ch06Cap` that implements the
`Callable` type class. Hence, you will be able to invoke `ppcall(cap, mi)`
on a `Ch06Cap` capability, making a protected procedure call. If however,
the other domain cannot handle such calls, or the other domain has lower
priority, the `Ch06Cap` in the API will not implement the `Callable` type class
which will statically preventing you from making such a call at compile time.

### Input Validation

The `mantle-tool` checks its input files for errors, but compared to the seL4
Core Platform, it is deliberately more lenient. For example, it won't require
you to specify the location of program images (ELF files), since you generally
won't have them when you're performing API generation. The format of the
system description files is described in detail in the seL4 Core Platform's
manual.

### Command-Line Usage

```
usage: mantletool [-c OUTPUT_C] [-i OUTPUT_AUI] [-m OUTPUT_AUM] [-g PD_NAME] input_file

positional arguments:
  input_file            the input System Description File

optional arguments:
  -h, --help            show this help message and exit
  -c OUTPUT_C, --output-c OUTPUT_C
                        output file for generated C headers
  -i OUTPUT_AUI, --output-aui OUTPUT_AUI
                        output file for generated Austral interface
  -m OUTPUT_AUM, --output-aum OUTPUT_AUM
                        output file for generated Austral module
  -g PD_NAME, --generate-api PD_NAME
                        generate an API for the given protection domain
```

Currently, `mantle-tool` supports the generation of API for only one protection
domain at a time. For multiple protection domains, you will need to run the
tool multiple times with the `-g PD_NAME` option for each domain. However,
multi-domain API generation is in the works, so stay tuned for this feature in
future updates.

When run without the `-g PD_NAME` option, `mantle-tool` will validate the given
system description, and return with an error code of zero if validation is
successful, without producing any other output.

## The static API

This section documents the static API functions which are available from the
`Mantle.Common` module.

### Types

#### `MantleUserCap` type

The MantleUserCap is the cornerstone capability type of libmantle's user-facing
abstractions. It acts as the root of the user-facing capability hierarchy.

A capability is a unique, unforgeable token that gives its owner permissions
to access an entity or object in system. One way to think of a capability is as
a pointer with built-in access rights.

The Austral language uses linear types to statically ensure that capabilities
cannot be duplicated, forged, or gained without proper authority. Capabilities
can only be created by proving that you have access to a more powerful
capability.

You cannot create `MantleUserCap` instances in your code. However,
the system itself hands over a value of type `MantleUserCap` as the first
argument to each of the programâ€™s three possible entry points
(`init`, `notified` and `protected`).

In your libmantle program, `MantleUserCap` serves as a means to mint other
capabilities, such as channel capabilities (see `mintChXX`). Aside from
minting new capabilities, a `MantleUserCap` value is also required to perform
specific functions, such as setting message registers using the `setMR` method.

**Note:** This is subject to change in future versions, where functionality
might be delegated to less powerful capabilities.

**Example:** Before you can notify channel 6, you need to reference its channel
capability. If you hold a capability `Ch06Cap` to the channel, you can refernce
it directly. If you hold a `muc: MantleUserCap`, you can instead mint a
capability to channel 6 as follows:
```ada
let ch06: Ch06Cap := mintCh06(&muc);
```

#### `MessageInfo` type

```ada
record MessageInfo: Free is
    label: Nat64;
    count: Nat16;
end;
```

Represents the same data as an `sel4cp_message` structure, used when making
and receiving protected procedure calls.

The `label` field is not parsed by the kernel in any way, so can be used to
encode additional information within the message itself. One common usage of
this field is to specify a requested operation in a protected procedure call.
For instance, if you have a server that has to support several operations,
you could assign different label values to each operation. When sending a
request to the server, set the label to the corresponding value of the
operation you want the server to perform.

The `count` represents the message length. It determines either the number of
message registers that the sending protection domain wishes to transfer when
sending, or the number of message registers that were actually transferred when
receiving.

**Note:** Currently, `libmantle` doesn't enforce any checks or constraints when
handling the `MessageInfo` type. You are free to invoke the record constructor
to create a MessageInfo with any `label` and `count` values. However, future
versions of `libmantle` might introduce more stringent checks for this type to
promote safer and more robust programming practices and prevent runtime faults.

#### `Message` type

```ada
record Message[T: Free]: Free is
    label: Nat64;
    count: Nat16;
    state: T;
end;
```

Represents a tuple of a `MessageInfo` type, along with another value of
a given type `T`.

Used in the `protected` entry point, where it allows the user to receive and
return a `MessageInfo` and the (updated) local state at the same time.


### Type classes

#### `Surrenderable` type class

```ada
typeclass Surrenderable(Cap: Linear) is
    method surrender(cap: Cap): Unit;
end;
```

The `Surrenderable` type class plays a crucial role in situations where you
hold a capability but no longer require its services in a particular function.

Most of the capability types exposed in the generated APIs implement this type
class, allowing you to explicitly surrender the capability, stating that you
won't refer to it further in the current function. This type class is
particularly useful due to Austral's linear type system, which necessitates
that each variable be used exactly once. If a capability isn't required for a
particular operation, failing to surrender it would prevent the program from
compiling.

**Example:** Let's say you're in a branch of your `notified` function and you
realize that no more reads or writes to the shared memory regions are
necessary. You can use this method to surrender your `mem: MemoryCaps`
capability by calling `surrender(mem);`.

**Note:** It's important to note that some capability types don't implement
the `Surrenderable` type class. This is generally the case when the
capabilities come with some inherent obligations. For instance, IRQ
capabilities do not implement this type class, as you can't merely discard
an IRQ notification; instead, it needs to be explicitly acknowledged.

#### `Notifiable` type class

```ada
typeclass Notifiable(Cap: Linear) is 
    generic [R:Region]
    method notify(cap: &[Cap,R]): Unit;
end;
```

This type class provides a method to send an asynchronous notification on a
communication channel capability. This functionality mirrors invoking
`sel4cp_notify`.

Channel capability types (see `ChXXCap`) instantiate this type class as long
as the given channel ID is declared part of a communication channel in the
System Description. Channel IDs declared part of an IRQ mapping do not
instantiate this type class.

Invoking `notify` does not consume the channel capability -
this is due to the use of the reference `&[Cap,R]`.

**Example:** To notify channel 6, one would generally do
```ada
let ch6: Ch06Cap := mintCh6(&muc);
notify(&ch6);
surrender(ch6);
```

**Note:** Users should remember that multiple consecutive notify calls will
not stack up; only one notification will be received, unless the other
protection domain handles the first notification in the meantime.


#### `Callable` type class

```ada
    typeclass Callable(Cap: Linear) is 
        generic [R:Region]
        method ppcall(cap: &[Cap,R], tag: MessageInfo): MessageInfo;
    end;
```

This type class provides a method to perform protected procedure calls between
different protection domains. It may be implemented by communication channel
capabilities, but not IRQ channel capabilities.

The `ppcall` method takes two arguments, a reference to a channel capability
and a `MessageInfo` structure, and returns a `MessageInfo` structure. The
input MessageInfo specifies the desired operation (through the label field)
and the number of message registers to be transmitted (through the `count`
field: e.g. a count of `4` would mean transferring register `0,1,2,3`).
The returned `MessageInfo` contains the `label` set by the called protection
domain, and the number of message registers received back (`count`).

The message registers can be set using the `setMR` function.

Invoking `ppcall` does not consume the channel capability -
this is due to the use of the reference `&[Cap,R]`.

Importantly, the libmantle API generator ensures at compile time that a
channel capability will only implement the `Callable` type class if the other
end of the channel provides a protected procedure (according to the System
Description) _and_ if it runs at a higher priority level. As a result, you can
be confident that invoking `ppcall` on a channel capability will not cause
a deadlock.


**Example:** To make a protected procedure call on channel 6, sending the value
`42` using only one message register, one can do
```ada
let ch6: Ch06Cap := mintCh6(&muc);
let tag: MessageInfo := MessageInfo(label => 0, count => 1);
setMR(&muc, 1, 42);
let response: MessageInfo := ppcall(&ch6, mi);
surrender(ch6);
```


#### `Ackable` type class

```ada
    typeclass Ackable(Cap: Linear) is
        method acknowledge(cap: Cap): Unit;
        method postpone(cap: Cap): Unit;
    end;
```

This type class provides methods for handling IRQ notifications. Only IRQ
capabilities (see `ChXXIrq`) implement this type class.

When an IRQ notification is received on a channel, libmantle hands the
protection domain a unique IRQ capability (see `ChXXIrq`).

When an IRQ is received, it's necessary to acknowledge the IRQ to clear
its trigger flag: this can be achieved by calling the `acknowledge` method
on the received `ChXXIrq` capability. This method consumes the IRQ capability
and acknowledges the IRQ, making it inactive until it is triggered again.

On the other hand, the `postpone` method is used when a protection domain
receives an IRQ but decides not to acknowledge it immediately. When invoked,
postpone merely consumes the IRQ capability without acknowledging the IRQ.
This leaves the IRQ active, and the protection domain will continue to receive
the same IRQ notification.

An interesting aspect of the `Ackable` type class is how it leverages linear
types. Linear types ensure that the IRQ capability can't be discarded without
either acknowledging or deliberately postponing the IRQ. This brings an elegant
and safe approach to IRQ management within libmantle: developers can handle
IRQs without worrying about potential mishandling or forgetting to acknowledge
the IRQs on some execution branch.

**Example:** To acknowledge an IRQ notification received from channel 6 inside
the `notified` method, one could do
```ada
case source of
    when Ch06(irq: Ch06Irq) do
        acknowledge(irq);
    ...
end case;
```

#### `Readable` type class

```ada
typeclass Readable(Cap: Linear) is
    generic [R: Region]
    method toSpan(object: &[Cap,R]): Span[Nat8, R];
end;
```

This type class provides a method that turns (references to) memory region
capabilities into Austral `Span`s. A `Span` can be thought of as a read-only
array of bytes, equipped with runtime bounds checking to prevent attempts to
read beyond the size of the memory region.

Invoking `toSpan` does not consume the memory region capability -
this is due to the use of the reference `&[Cap,R]`, and means that multiple
read-only references to the same memory region can be created.

Since the seL4 Core Platform is static, and shared memory regions cannot be
destroyed, the created `Span`s can safely live in the `Static` region.

**Example:** Given a memory region mapped read-only in the system description,
with virtual address `region_vaddr`, one can access the region's first byte
inside the `notified` method as follows:
```ada
let { regionVaddr: RegionVaddrRCap } := mem;
let array: Span[Nat8, Static] := toSpan(&regionVaddr);
let firstByte: Nat8 := array[0];
```

#### `Writable` type class

```ada
typeclass Writable(Cap: Linear) is
    generic [R: Region]
    method toSpanWrite(object: Cap): Span![Nat8, R];
end;
```

This type class provides a method that turns memory region capabilities into
Austral `Span!`s. A `Span!` can be thought of as a read-write array of bytes,
equipped with runtime bounds checking to prevent attempts to read or write
beyond the size of the memory region.

Invoking `toSpanWrite` consumes the memory region capability, and means that
user code will have at most one read-write reference to each memory region.

Since the seL4 Core Platform is static, and shared memory regions cannot be
destroyed, the created `Span`s can safely live in the `Static` region.

**Example:** Given a memory region mapped read-write in the system description,
with virtual address `region_vaddr`, one can set the region's first byte
inside the `notified` method as follows:
```ada
let { regionVaddr: RegionVaddrRWCap } := mem;
var array: Span![Nat8, Static] := toSpanWrite(regionVaddr);
array[0] := 42;
```

#### Functions

The following functions are provided for getting and setting message registers:
```ada
generic [R: Region]
function setMR(cap: &[MantleUserCap, R], mr: Nat8, value: Nat64): Unit
generic [R: Region]
function getMR(cap: &[MantleUserCap, R], mr: Nat8): Nat64
```

## The generated APIs

This section documents the functions and types generated dynamically based on
your system description by libmantle. They can be imported from the
`Mantle.Generated` module.

### Types

#### `ChXXCap` type

```ada
type ChXXCap: Linear
```

A capability that allows its holder to perform operations involving the channel
with identifier `XX`. E.g. channel id 6 has a corresponding capability type
`Ch06Cap`.

These capabilities can be minted using the corresponding `mintChXX` function.

A communication channel capability always has instances for the following type
classes:

```ada
instance Surrenderable(ChXXCap);
instance Notifiable(ChXXCap);
```

Additionally, if the other end of the communication channel provides a
protected procedure call, and its priority is higher than that of the current
protection domain, the communication channel capability will have an instance

```ada
instance Callable(ChXXCap);
```

An IRQ channel capability only has a `Surrenderable(ChXXCap)` instance, since
such channels do not allow notifications or protected procedure calls to be
made.

Channel ids which are not part of either a communication channel or an IRQ
channel will not have a corresponding `ChXXCap` type in the generated API.


#### `ChXXIrq` type

```ada
type ChXXIrq: Linear
```

A capability that allows its holder to acknowledge or postpone the IRQ mapped
to the channel identifier `XX` in the system description.

These capabilities cannot be minted by the programmer: the only way to acquire
a value of this type is being handed one by the system when receiving a
notification on an IRQ channel.

An IRQ capability only has instances of the `Ackable` type class. In particular
it has no `Surrenderable` instance.

Channel ids which are not part of an IRQ channel will not have a corresponding
`ChXXIrq` type in the generated API.


#### `XxxxRWCap` type

```ada
type XxxxRWCap: Linear
```

A capability that allows its holder to acquire a read-write reference to the
mapped memory region with name `Xxxx`.

These capabilities cannot be minted by the programmer: instead, they are handed
to the entry points (`init`, `notified`, `protected`) by the system, as fields
in the `mem: MemoryCaps` record.

For example, if the system description specifies that the protection domain
has a memory region mapped with write permissions into its virtual address
space, with the symbol `region_vaddr`, then the `MemoryCaps` record will
contain a field `regionVaddr: RegionVaddrRWCap`. Note that if the memory region
is mapped with read-only permissions, the field will still exist but will have
type `regionVaddr: RegionVaddrRCap` instead.

These capabilities come with a `Writable(XxxxRWCap)`. They also come with a
function `toXxxxRCap(cap)`, which allows the capability to decay to an
`XxxxRCap` capability.


#### `XxxxRCap` type

```ada
type XxxxRCap: Linear
```

A capability that allows its holder to acquire read-only references to the
mapped memory region with name `Xxxx`.

These capabilities cannot be minted by the programmer: instead, they are handed
to the entry points (`init`, `notified`, `protected`) by the system, as fields
in the `mem: MemoryCaps` record.

These capabilities come with a `Writable(XxxxRWCap)`. They also come with a
function `toXxxxRCap(cap)`, which allows the capability to decay to an
`XxxxRCap` capability.

For example, if the system description specifies that the protection domain
has a memory region mapped without write permissions into its virtual address
space, with the symbol `region_vaddr`, then the `MemoryCaps` record will
contain a field `regionVaddr: RegionVaddrRCap`. Note that if the memory region
is mapped with write permissions, the field will still exist but will have type
`regionVaddr: RegionVaddrRWCap` instead.

These capabilities each come with a `Readable(XxxxRCap)` instance.

#### `NotificationSource` type

```ada
union NotificationSource: Linear is
    case ChXX;
    ...
    case ChYY is
        irq: ChYYIrq;
    ...
    case UnknownNotification is
        number: Nat32;
end;
```

This union type identifies the source channel id of a notification.
Accordingly, it has a constructor `ChXX()` for each channel id that takes part
in a communication channel according to the system specification, and a
constructor `ChYY(irq: ChYYIrq)` for each channel id that takes part in an IRQ
channel according to the system specification.

It also has a case constructor `UnknownNotification(number: Nat32)`, for
notifications that arrive on a channel id `number` that is not specified in the
system description.

**Example:** The main argument of the `notification` entry point has type
`source: NotificationSource`. To consume the `source`, you can use a case
statement:
```ada
case source of
    when ChXX do
      -- actions for channel XX
    when ChYY(irq: ChYYIrq) do
      -- actions for channel YY
      acknowledge(irq);
    when UnknownNotification(number: Nat32) do
      -- actions on unknown channel
end case;
```

#### `PpcallSource` type

```ada
union NotificationSource: Linear is
    case FromChXX;
    ...
    case FromChYY;
    ...
    case UnknownPpcall is
        number: Nat64;
end;
```

This union type identifies the source channel id of a protected procedure call.
Accordingly, it has a constructor `FromChXX()` for each channel id that takes
part in a communication channel according to the system specification, as long
as the priority of the other end is lower than that of the current protection
domain.

It also has a case constructor `UnknownPpcall(number: Nat64)`, for
protected calls that arrive on a channel id `number` that is not specified
or permissible according to the system description.

**Example:** The main argument of the `protected` entry point has type
`source: PpcallSource`. To consume the `source`, you can use a case
statement:
```ada
case source of
    when FromChXX do
      -- actions for channel XX
      return MessageInfo(..);
    when UnknownPpcall(number: Nat64) do
      -- actions on unknown channel
      return MessageInfo(..);
end case;
```

#### `MemoryCaps` type

```ada
record MemoryCaps: Linear is
  xxxx: XxxxRWCap;
  ...
  yyyy: YyyyRCap;
  ...
end;
```

This record type holds capabilities to all mapped memory regions of the
protection domain. 

These records cannot be created by the programmer: instead, a value of
this type, containing all the individual capabilities, is handed to the entry
points (`init`, `notified`, `protected`) as the `mem: MemoryCaps` argument.

If the system description specifies that the protection domain has a memory
region mapped with write permissions into its virtual address space, with the
associated setvar symbol `xxxx`, then the generated `MemoryCaps` record will
contain a corresponding field `xxxx: XxxxRWCap`. Note that if the memory region
is mapped with read-only permissions, the field will still exist but will have
type `xxxx: XxxxRCap` instead.

**Example:** To use the `mem` argument, you have to destructure it. E.g. if you
have one memory region, `region_vaddr`, mapped writable, and you want to write
42 into its first byte, you'd do:
```ada
let { regionVaddr: RegionVaddrRWCap } := mem;
var array: Span![Nat8, Static] := toSpanWrite(mem);
array[0] := 42;
```

## Project structure

To implement a libmantle protection domain, you need to write a module,
called `module Program` which implements the following interface:

```ada
import Mantle.Common (
  MantleUserCap,
  MessageInfo,
  Message
);

import Mantle.Generated (
  MemoryCaps,
  NotificationSource,
  PpcallSource
);

module Program is
  type LocalState: Free;
  function notified(cap: MantleUserCap, mem: MemoryCaps, source: NotificationSource, state: LocalState): LocalState;
  function protected(cap: MantleUserCap, mem: MemoryCaps, source: PpcallSource, message: Message[LocalState]): Message[LocalState];
  function init(cap: MantleUserCap, mem: MemoryCaps): LocalState;
end module.
```

The `notified`, `protected` and `init` functions are called your program's
_entry points_.

These are entirely analogous to the corresponding seL4 Core Platform entry
points. Keep in mind that implementing the `protected` entry point is not
optional: if your protection domain does not provide a protected procedure
call, you should implement a deliberate failure case here instead of failing
silently (as libsel4cp does by default).

An important difference between seL4 Core Platform and libmantle entry points
comes from the fact that seL4 Core Platform entry points can maintain
persistent state by modifying global variables. Since Austral lacks global
variables, libmantle takes a different approach to persistent state: you can
define a `LocalState` type. A value of this type is returned by all entry
points, and saved by libmantle. On the subsequent call, the entry point
receives the saved value as an argument.

To build your protection domain ELF file, you have to follow the steps below.
The steps assume that your `Program` module is located in the `program.aum`
file, and that `generated.c/aum/aui` contain the interfaces generated by
libmantle.

**1.** First, compile your program into C using the Austral compiler:
```bash
austral compile \
  library/unsafe.aui,library/unsafe.aum \
  library/common.aui,library/common.aum \
  generated.aui,generated.aum \
  program.aui,program.aum \
  library/main.aum \
  --entrypoint=Mantle.Main:main \
  --target-type=c \
  --output=program.c                
```
where `library/` is the path to the library library. Note that your program's
main entry point has to be the main function in the library.

**2.** The current version of the Austral compiler includes builtins
and headers (prelude.c) that are not suitable for non-POSIX environments.
We need to stub these out in the generated code to make it compile. These
include `au_stdout`, `au_stderr`, `au_stdin`, `au_abort_internal`,
`au_abort`, `au_printf` `au_calloc`, `au_realloc`, `au_memmove`, `au_memcpy`,
`au_free`. Future versions of libmantle will provide their own header
and a script to replace these automatically.

**3.** The generated C headers have to be included in the C file using
`#include "generated.c"`. The generated header handles including the main
`libmantle.c` file, which includes the seL4 Core Platform library, so can
be compiled the usual way, by linking it against `libsel4cp.a` using the
`aarch64-none-elf-gcc` compiler into an ELF binary.

**4.** The resulting ELF binary can be given to the seL4 Core Platform tool,
along with the system description file, to build the system image as usual.
You can then run the system image on `qemu` or an sel4cp-supported board.

If you just want to try libmantle, we recommend not going through this
whole process to run your ELF on the actual seL4 Core Platform.

Instead, you can use `--target-type=tc` to type check your program without
running it, or see the Tutorial / Quick Start Guide for an easier way to test
your protection domain logic without going through the seL4 Core Platform.

## FAQ

**Q: Why can't protection domains thread through `Linear` local state via
their entry points?**

A: At first sight, it seems reasonable to have the `Program` module export
a type `type UserState: Linear;`, which could be saved and threaded through
`notified` calls by the system.

This might be implemented at some point in the future, but it requires careful
investigation. For example, this would allow the user to define

```aud
record UserState: Linear is
  savedIrq: Ch06Irq;
end;
```

which would allow for an IRQ capability to be saved without either explicit
acknowledgment or postponement; the capability might be
reloaded later by destructuring the `UserState`, therefore duplicating the
IRQ capability. Maybe this issue could be mitigated with fancier design, but it
will require careful reasoning.

## A word of warning

Congratulations on reaching the end of the libmantle API manual!
We hope you found this information useful and clear - if you think that
something is missing, be sure to create an issue, or submit a pull request.

And keep in mind the following:

* libmantle is an experimental project, currently in version 0.x.
  This means that libmantle comes with its share of instability.
  Changes may be frequent and, at times, substantial.
  Future versions will not maintain complete compatibility with this API,
  so please be prepared for potential changes as the library continues to
  evolve.

* Given the experimental status of libmantle, we advise against using it (or
  even thinking about using it) in high-assurance scenarios for now. It's
  better suited for exploration, learning, and environments where potential
  risks from bugs or violated guarantees are negligible. As the project
  matures, we aim to increase its reliability and safety, but for now, please
  exercise extreme caution.

* Finally, libmantle is provided "as is," without warranty of any kind, express
  or implied. That means we do not make any guarantees about its functionality
  or fitness for any particular purpose.

Thank you for choosing to explore libmantle, and we're excited to see how
you'll use it to push the boundaries of what's possible on seL4-based systems.
